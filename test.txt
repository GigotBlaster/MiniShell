# Commande simple

/bin/ls


# Arguments

/bin/ls --color /

/bin/ls nothing


# Echo

echo hey"you"

echo "hey    you"

echo -n hey"you"

echo -n -n -n -n hey -n 42


# Exit

exit

exit 12

exit 1 a

exit ab 1


# Valeur de retour d'un processus

echo hey ; echo $?

/bin/ls fichiernul ;echo $?

a=b c=d notfound1 | echo $? $a | notfound2 ; echo $? ; echo $?


# Point virgule

ls ; echo hey

ls;echo hey


# Signaux 

#	ctrl-C dans un prompt vide
#	ctrl-\ dans un prompt vide
#	ctrl-D dans un prompt vide
#	ctrl-C dans un prompt après que vous ayiez écrit des choses
#	ctrl-D dans un prompt après que vous ayiez écrit des choses
#	ctrl-\ dans un prompt après que vous ayiez écrit des choses
#	ctrl-C après avoir lancé une commande bloquante (cat)
#	ctrl-\ après avoir lancé une commande bloquante (cat)
#	ctrl-D après avoir lancé une commande bloquante (cat)


# Guillemets

/bin/echo a"bc      def\"g\" " "hi ; j"

# Env
env

new="hey"; env

# Export

export new; env

OLDPWD="lost"; env

# Unset

export new="i'm here"; echo $new; unset new; echo $new


# Variable d'environnement

test="echo    hey"

$test

echo $test

echo "$test"

"$test"


# Pwd

pwd

pwd .

pwd ..

pwd a b cd e


# Path relatif

../../../../bin/ls

./minishell


# Path d'environnement

ls | wc -c

unset PATH ; ls

PATH="directory1" ; ls

PATH="directory1:directory2:/bin" ; ls


# Simple quotes

echo 'this is "a simple $test   ;  ' | cat -e


# Redirection

echo hey >file ; cat file

> file echo hey ; cat file

filename="two parts"; echo hey > $filename

echo hey >> file ; cat file

cat < file > copy ; cat copy; rm file copy

echo test > file1 > file2 > file3; tail file1 file2 file3 ; rm file1 file2 file3

echo Bonjour >file1 jeune homme; cat file1

echo Bonjour >file1 jeune homme > file2 ca va >file3; tail file1 file2 file3; rm file1 file2 file3

echo bonjour >f1 mec >f2 | echo ok > f3 | echo >f4 >>f5 oui | echo final >f6 ; tail f1 f2 f3 f4 f5 f6 ; rm f1 f2 f3 f4 f5 f6

filename="file_test" ; echo "hi Bro" > $filename ; cat $filename ; rm $filename

echo test > file01 > file02 > file03 ; tail file01 file02 file03 ; rm file01 file02 file03


# Pipes

cat tests.txt | grep hey | more

ls fichiernul | grep bla | more

ls | echo OK

ls | echo bonjour > file11 | ls ; rm file11

ls | hexdump > f0 | echo Bonjour >f1 jeune homme > f2 ca va >f3 | ls ; tail f0 f1 f2 f3 ; rm f0 f1 f2 f3

echo hey >> file ; hexdump file | cat

echo hey >> file ; hexdump file | cat -e; rm file

sleep 5 | sleep 5 | sleep 5 | sleep 5 | sleep 5

sleep 5 | sleep 5 | sleep 5 ; sleep 5

















///////////////////////////////////

static int	count_words(const char *str, char charset)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (str[i])
	{
		while (str[i] && (str[i] == charset))
			i++;
		if (str[i] && !(str[i] == charset))
		{
			count++;
			while (str[i] && !(str[i] == charset))
				i++;
		}
	}
	return (count);
}

static void	free_tab_exec(char ***s, int i)
{
	while (i-- > 0)
		free((*s)[i]);
	free(*s);
	*s = NULL;
}

char	*ft_strncpy2(char *dest, const char *src, unsigned int n)
{
	unsigned int	i;

	i = 0;
	while (src[i] && i < n)
	{
		dest[i] = src[i];
		i++;
	}
	while (i < n)
	{
		dest [i] = '\0';
		i++;
	}
	return (dest);
}

static void	fill_words(char **split, const char *str, char charset, int words)
{
	int	i;
	int	j;
	int	k;

	i = 0;
	j = 0;
	k = 0;
	while (i < words)
	{
		while (str[j] && str[j] == charset)
			j++;
		k = 0;
		while (str[j + k] && !(str[j + k] == charset))
			k++;
		split[i] = ft_calloc((k + 1), sizeof(char));
		if (!split[i])
			return (free_tab_exec(&split, i));
		ft_strncpy2(split[i], &str[j], k);
		j += k;
		i++;
	}
	split[i] = 0;
}

char	**ft_splitexec(const char *str, char charset)
{
	char	**split;
	int		words_c;

	if (str == NULL)
		return (NULL);
	words_c = (count_words(str, charset));
	split = ft_calloc((words_c + 1), sizeof(char *));
	if (split == NULL)
		return (NULL);
	fill_words(split, str, charset, words_c);
	return (split);
} 
////////////////////////////////////////////////////////////

int	is_a_redirection(char *str)
{
	if (!strcmp(str, ">"))
		return (1);
	if (!strcmp(str, ">>"))
		return (2);
	if (!strcmp(str, "<"))
		return (3);
	if (!strcmp(str, "<<"))
		return (4);
	return (0);
}

void	free_tab2(char **tab)
{
	int	i;

	i = 0;
	if (!tab)
		return ;
	while (tab[i])
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

void	free_cmd_ln(t_cmd *cmd)
{
	free(cmd->redirections);
	free_tab2(cmd->fichiers);
	free_tab2(cmd->arguments);
	free(cmd);
}

t_cmd	*token(char *str)
{
	int		i;
	char	**input;
	t_cmd	*cmd;
	int		red_nb;
	int		args_nb;
	int		r;
	int		a;

	// rajouter espaces derriere les <>
	// split selon les whitespaces : obtient qqch du style {ls}{-la}{>>}{out}{<}{in}
	input = ft_splitexec(str, ' ');
	if (!input)
		return (NULL);
	// si appelle la fonction token() depuis le main,
	// meme pas beoin de malloc la structure commande (peut passer son adresse)
	cmd = calloc(sizeof(t_cmd), 1);
	if (!cmd)
		return (free_tab2(input), NULL);
	/*  ------------------------ A METTRE DANS AUTRE FONCTION (NORME) ------------------*/
	// definit le nombre de redirections et d'arguments de commandes que l on va avoir a stocker
	i = 0;
	red_nb = 0;
	args_nb = 0;
	while (input[i])
	{
		if (is_a_redirection(input[i]))
		{
			red_nb++;
			i++;
		}
		else
			args_nb++;
		i++;
	}
	// alloue l esoace memoire necessaire pour les types de redirections
	cmd->redirections = calloc(sizeof(int), red_nb);
	if (!cmd->redirections)
	{
		return (free_tab2(input), NULL);
	}
	// alloue l espace memoire necessaire pour les fichiers correspondant a chaque redirection
	cmd->fichiers = calloc(sizeof(char *), red_nb + 1);
	if (!cmd->fichiers)
		return (free_cmd_ln(cmd), NULL);
	cmd->arguments = calloc(sizeof(char *), args_nb + 1);
	if (!cmd->arguments)
		return (free_cmd_ln(cmd), NULL);
	/*  ------------------------- FIN DE LA SOUS-FONCTION ----------------------------- */
	i = 0;
	r = 0;
	a = 0;
	while (input[i])
	{
		if (is_a_redirection(input[i]))
		{
			cmd->redirections[r] = is_a_redirection(input[i]);
			cmd->fichiers[r] = strdup(input[++i]);
			if (!cmd->fichiers[r++])
				return (free_cmd_ln(cmd), NULL);
		}
		else
		{
			cmd->arguments[a] = strdup(input[i]);
			if (!cmd->arguments[a++])
				return (free_cmd_ln(cmd), NULL);
		}
		i++;
	}
	cmd->command = cmd->arguments[0];
	return (cmd);
}

/*  ------------------- fonction d affichage ----------------------------- */

// void print_cmd(t_cmd *cmd) 
// {
// 	if (cmd->command)
// 		fprintf(stderr, "CMD: [%s]\n", cmd->command);
// 	if (cmd->arguments[0])
// 	{
// 		fprintf(stderr, "ARG: ");
// 		for (int i = 0; cmd->arguments[i]; i++) 
// 			fprintf(stderr, "[%s]", cmd->arguments[i]);
// 		fprintf(stderr, "\n");
// 	}
// 	for (int i = 0; cmd->fichiers[i]; i++)
//         fprintf(stderr, "[%i]:%s\n", cmd->redirections[i], cmd->fichiers[i]);
// }

// void	init_loop(t_data *data, char *input)
// {
// 	data_>prev_pipe = -1;
// }

// int	main(int ac, char **av)
// {
// 	(void)ac;
// 	t_cmd *cmd;
// 	while (1)
// 	{
// 		char *str = readline("> ");
// 		if (!str)
// 			exit(1);
// 		if (!*str)
// 			continue ;
// 		add_history(str);
// 		cmd = token(str);
// 		print_cmd(cmd);
// 		free_cmd_ln(cmd);
// 	}
// 	cmd = token(av[1]);
// 	print_cmd(cmd);
// 	return(0);
// }
