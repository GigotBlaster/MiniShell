# Commande simple

/bin/ls // OK


# Arguments

/bin/ls --color // OK

/bin/ls nothing // OK


# Echo OK // sans le bultin

echo hey"you" // OK

echo "hey    you" // OK

echo -n hey"you" // OK

echo -n -n -n -n hey -n 42 // OK


# Exit // sans le builtin

exit // still not done

exit 12 // still not done

exit 1 a // still not done

exit ab 1 // still not done


# Valeur de retour d'un processus // still not done

echo hey ; echo $? // avec ';' ne doit pas segfault

/bin/ls fichiernul ;echo $?

a=b c=d notfound1 | echo $? $a | notfound2 ; echo $? ; echo $?


# Point virgule

ls ; echo hey // OK

ls;echo hey // OK


# Signaux 

#	ctrl-C dans un prompt vide // doit quitter la ligne mais pas le prompt
#	ctrl-\ dans un prompt vide // quit core dumped
#	ctrl-D dans un prompt vide //ca ecrit exit
#	ctrl-C dans un prompt après que vous ayiez écrit des choses // ca quitte le programme
#	ctrl-D dans un prompt après que vous ayiez écrit des choses // ca ne fait rien
#	ctrl-\ dans un prompt après que vous ayiez écrit des choses // quit core dumped
#	ctrl-C après avoir lancé une commande bloquante (cat) // ok
#	ctrl-\ après avoir lancé une commande bloquante (cat) // quit core dumped
#	ctrl-D après avoir lancé une commande bloquante (cat) // ca reste dans le prompt mais quitte le commande


# Guillemets

/bin/echo a"bc      def\"g\" " "hi ; j" OK

# Env
env // OK

new="hey"; env // OK

# Export

export new; env

OLDPWD="lost"; env

# Unset

export new="i'm here"; echo $new; unset new; echo $new


# Variable d'environnement

test="echo    hey" // OK

$test // OK

echo $test // OK

echo "$test" // OK

"$test" // OK


# Pwd

pwd // OK

pwd . // OK

pwd .. // OK

pwd a b cd e // OK


# Path relatif

../../../../bin/ls // Ok

./minishell // OK


# Path d'environnement

ls | wc -c // OK

unset PATH ; ls

PATH="directory1" ; ls

PATH="directory1:directory2:/bin" ; ls


# Simple quotes

echo 'this is "a simple $test   ;  ' | cat -e // OK


# Redirection

echo hey >file ; cat file // OK

> file echo hey ; cat file // OK

filename="two parts"; echo hey > $filename // manque le msg d'erreur et ne doit pas creer le fichier filename / syntax error near unexpected token `newline'

echo hey >> file ; cat file // OK

cat < file > copy ; cat copy; rm file copy // OK

echo test > file1 > file2 > file3; tail file1 file2 file3 ; rm file1 file2 file3

echo Bonjour >file1 jeune homme; cat file1 // OK

echo Bonjour >file1 jeune homme > file2 ca va >file3; tail file1 file2 file3; rm file1 file2 file3 // KO ne doit pas ecrire dans tout les file seulement le dernier

echo bonjour >f1 mec >f2 | echo ok > f3 | echo >f4 >>f5 oui | echo final >f6 ; tail f1 f2 f3 f4 f5 f6 ; rm f1 f2 f3 f4 f5 f6 // OK

filename="file_test" ; echo "hi Bro" > $filename ; cat $filename ; rm $filename // echec il me dis que la commande n'existe pas alors que je veux juste qu'il me renvoie 

echo test > file01 > file02 > file03 ; tail file01 file02 file03 ; rm file01 file02 file03 // OK


# Pipes

cat o | grep hey | more // OK

ls fichiernul | grep bla | more // OK

ls | echo OK

ls | echo bonjour > file11 | ls ; rm file11 // ;rm pas gere

ls | hexdump > f0 | echo Bonjour >f1 jeune homme > f2 ca va >f3 | ls ; tail f0 f1 f2 f3 ; rm f0 f1 f2 f3 // OK

echo hey >> file ; hexdump file | cat // OK

echo hey >> file ; hexdump file | cat -e; rm file // OK

sleep 5 | sleep 5 | sleep 5 | sleep 5 | sleep 5 // OK

sleep 5 | sleep 5 | sleep 5 ; sleep 5 // OK

cat | cat | cat | cat | ls // KO doit bien fermer au bout du nombre de cat